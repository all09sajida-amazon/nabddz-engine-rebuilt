// scripts/manager.js
const fs = require('fs');
const path = require('path');
const { Octokit } = require('@octokit/rest');
const child_process = require('child_process');

const MODE = process.env.MODE || 'full';
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const PRIVATE_KEY = process.env.NABDZ_PRIVATE_KEY;

const repoOwner = process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[0] : null;
const repoName = process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[1] : null;

if (!GITHUB_TOKEN) {
  console.error('GITHUB_TOKEN missing — aborting.');
  process.exit(2);
}

const octokit = new Octokit({ auth: GITHUB_TOKEN });

function log(msg, ...rest) {
  const t = new Date().toISOString();
  console.log(`[manager ${t}] ${msg}`, ...rest);
  fs.appendFileSync(path.join('tmp', `manager-${MODE}.log`), `[${t}] ${msg} ${rest.length?JSON.stringify(rest):''}\n`);
}

async function runDecryptAndPersist() {
  const payloadPathJson = path.join('tmp', 'payload.json');
  const payloadPathB64 = path.join('tmp', 'payload.b64');

  if (fs.existsSync(payloadPathB64) && !fs.existsSync(payloadPathJson)) {
    const b64 = fs.readFileSync(payloadPathB64, 'utf8').trim();
    const buff = Buffer.from(b64, 'base64');
    fs.writeFileSync(payloadPathJson, buff.toString('utf8'));
  }

  if (!fs.existsSync(payloadPathJson)) {
    log('No payload found to process.');
    return { processed: 0 };
  }

  log('Running decrypt_and_persist.js on payload.json');
  try {
    child_process.execSync(`node ./scripts/decrypt_and_persist.js ${payloadPathJson}`, { stdio: 'inherit', env: Object.assign({}, process.env, { PRIVATE_KEY }) });
    log('decrypt_and_persist.js completed.');
    const files = getFilesRecursive('data/logs');
    return { processed: files.length };
  } catch (err) {
    log('decrypt_and_persist.js failed:', String(err));
    return { processed: 0, error: String(err) };
  }
}

function getFilesRecursive(dir) {
  if (!fs.existsSync(dir)) return [];
  const out = [];
  (function walk(d){
    const items = fs.readdirSync(d);
    for (const it of items) {
      const full = path.join(d, it);
      const st = fs.statSync(full);
      if (st.isDirectory()) walk(full);
      else out.push(full);
    }
  })(dir);
  return out;
}

async function commitAndPushDataBranch() {
  try {
    log('Preparing git commit for data-store branch.');
    child_process.execSync('git config user.email "nabdz-bot@users.noreply.github.com"');
    child_process.execSync('git config user.name "nabdz-bot"');
    child_process.execSync('git add data/logs || true');
    try {
      child_process.execSync(`git commit -m "ingest: logs persisted (${new Date().toISOString()})" || true`);
    } catch(e){}
    child_process.execSync('git push origin HEAD:data-store');
    log('Pushed to data-store branch.');
    return true;
  } catch (err) {
    log('Failed to push data-store branch:', String(err));
    return false;
  }
}

async function createSummaryIssue(summary) {
  try {
    const title = `Nabdz ingest report — ${new Date().toISOString()}`;
    const body = `**Mode:** ${MODE}\n\n${summary}\n\n*Generated by Nabdz Manager.*`;
    const res = await octokit.issues.create({
      owner: repoOwner,
      repo: repoName,
      title,
      body
    });
    log('Created issue:', res.data.html_url);
    return res.data.html_url;
  } catch (err) {
    log('Failed to create issue:', String(err));
    return null;
  }
}

(async () => {
  log('Manager started in mode', MODE);

  // 1. Check out the data-store branch before running
  try {
      log('Fetching and checking out data-store branch...');
      child_process.execSync('git fetch origin data-store:data-store || true');
      child_process.execSync('git checkout data-store || git checkout -b data-store');
      log('Checked out data-store.');
  } catch (err) {
      log('Failed to checkout data-store branch:', String(err));
      child_process.execSync('git checkout main'); // Fallback to main
  }

  let report = '';

  if (MODE === 'ingest' || MODE === 'full') {
    const r = await runDecryptAndPersist();
    report += `Processed payload files: ${r.processed}\n`;
    if (r.error) report += `Errors: ${r.error}\n`;
    const pushed = await commitAndPushDataBranch();
    report += `Pushed to data-store: ${pushed}\n`;
  }

  const files = getFilesRecursive('data/logs');
  report += `Total persisted files: ${files.length}\n`;

  const issueUrl = await createSummaryIssue(report);
  report += `Issue: ${issueUrl}\n`;

  log('Manager finished. Summary:\n' + report);
  process.exit(0);
})();
